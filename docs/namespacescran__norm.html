<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_norm: scran_norm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_norm
   </div>
   <div id="projectbrief">Scaling normalization of single-cell data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_norm Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Scaling normalization of single-cell data.  
<a href="namespacescran__norm.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors()</a></code> and <code><a class="el" href="namespacescran__norm.html#ac59a8b6eca7e5c8d71cd21352b4ff393">center_size_factors_blocked()</a></code>.  <a href="structscran__norm_1_1CenterSizeFactorsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__norm_1_1ChoosePseudoCountOptions.html">ChoosePseudoCountOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__norm.html#a8948eac81e727615b19195686c81f666">choose_pseudo_count()</a></code>.  <a href="structscran__norm_1_1ChoosePseudoCountOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__norm_1_1NormalizeCountsOptions.html">NormalizeCountsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__norm.html#a141ebdc51024210f4c27902446fa4169">normalize_counts()</a></code>.  <a href="structscran__norm_1_1NormalizeCountsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html">SanitizeSizeFactorsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__norm.html#a16132309197e8d7a1d7d238a3685deda">sanitize_size_factors()</a></code>.  <a href="structscran__norm_1_1SanitizeSizeFactorsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnostics for the size factors.  <a href="structscran__norm_1_1SizeFactorDiagnostics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a47460312428a74877116e789da012aba" id="r_a47460312428a74877116e789da012aba"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a47460312428a74877116e789da012aba">CenterBlockMode</a> : char { <b>PER_BLOCK</b>
, <b>LOWEST</b>
 }</td></tr>
<tr class="separator:a47460312428a74877116e789da012aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ecb96a14f7df7cd0d5be4599766d2" id="r_a946ecb96a14f7df7cd0d5be4599766d2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a946ecb96a14f7df7cd0d5be4599766d2">SanitizeAction</a> : char { <b>IGNORE</b>
, <b>ERROR</b>
, <b>SANITIZE</b>
 }</td></tr>
<tr class="separator:a946ecb96a14f7df7cd0d5be4599766d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a01f3a3610590fb1286c4b7c8d0eb01c5" id="r_a01f3a3610590fb1286c4b7c8d0eb01c5"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:a01f3a3610590fb1286c4b7c8d0eb01c5"><td class="memTemplItemLeft" align="right" valign="top">SizeFactor_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a01f3a3610590fb1286c4b7c8d0eb01c5">center_size_factors_mean</a> (size_t num, const SizeFactor_ *size_factors, <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *diagnostics, const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:a01f3a3610590fb1286c4b7c8d0eb01c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91783332304c92e0e02696d2e9358549" id="r_a91783332304c92e0e02696d2e9358549"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:a91783332304c92e0e02696d2e9358549"><td class="memTemplItemLeft" align="right" valign="top">SizeFactor_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors</a> (size_t num, SizeFactor_ *size_factors, <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *diagnostics, const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:a91783332304c92e0e02696d2e9358549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c4087475faf7ba8a31d16a70669de" id="r_af26c4087475faf7ba8a31d16a70669de"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ , typename Block_ &gt; </td></tr>
<tr class="memitem:af26c4087475faf7ba8a31d16a70669de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; SizeFactor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#af26c4087475faf7ba8a31d16a70669de">center_size_factors_blocked_mean</a> (size_t num, const SizeFactor_ *size_factors, const Block_ *block, <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *diagnostics, const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:af26c4087475faf7ba8a31d16a70669de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59a8b6eca7e5c8d71cd21352b4ff393" id="r_ac59a8b6eca7e5c8d71cd21352b4ff393"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ , typename Block_ &gt; </td></tr>
<tr class="memitem:ac59a8b6eca7e5c8d71cd21352b4ff393"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; SizeFactor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#ac59a8b6eca7e5c8d71cd21352b4ff393">center_size_factors_blocked</a> (size_t num, SizeFactor_ *size_factors, const Block_ *block, <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *diagnostics, const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:ac59a8b6eca7e5c8d71cd21352b4ff393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12e0ead5f0365bd2c525b9597ed933d" id="r_aa12e0ead5f0365bd2c525b9597ed933d"><td class="memTemplParams" colspan="2">template&lt;typename Float_ &gt; </td></tr>
<tr class="memitem:aa12e0ead5f0365bd2c525b9597ed933d"><td class="memTemplItemLeft" align="right" valign="top">Float_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#aa12e0ead5f0365bd2c525b9597ed933d">choose_pseudo_count_raw</a> (size_t num, Float_ *size_factors, const <a class="el" href="structscran__norm_1_1ChoosePseudoCountOptions.html">ChoosePseudoCountOptions</a> &amp;options)</td></tr>
<tr class="separator:aa12e0ead5f0365bd2c525b9597ed933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8948eac81e727615b19195686c81f666" id="r_a8948eac81e727615b19195686c81f666"><td class="memTemplParams" colspan="2">template&lt;typename Float_ &gt; </td></tr>
<tr class="memitem:a8948eac81e727615b19195686c81f666"><td class="memTemplItemLeft" align="right" valign="top">Float_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a8948eac81e727615b19195686c81f666">choose_pseudo_count</a> (size_t num, const Float_ *size_factors, const <a class="el" href="structscran__norm_1_1ChoosePseudoCountOptions.html">ChoosePseudoCountOptions</a> &amp;options)</td></tr>
<tr class="separator:a8948eac81e727615b19195686c81f666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ebdc51024210f4c27902446fa4169" id="r_a141ebdc51024210f4c27902446fa4169"><td class="memTemplParams" colspan="2">template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class SizeFactors_ &gt; </td></tr>
<tr class="memitem:a141ebdc51024210f4c27902446fa4169"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; OutputValue_, Index_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a141ebdc51024210f4c27902446fa4169">normalize_counts</a> (std::shared_ptr&lt; const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, Index_ &gt; &gt; counts, SizeFactors_ size_factors, const <a class="el" href="structscran__norm_1_1NormalizeCountsOptions.html">NormalizeCountsOptions</a> &amp;options)</td></tr>
<tr class="separator:a141ebdc51024210f4c27902446fa4169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af1b1c1e7124933e4335f82fd41f027" id="r_a8af1b1c1e7124933e4335f82fd41f027"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:a8af1b1c1e7124933e4335f82fd41f027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a8af1b1c1e7124933e4335f82fd41f027">check_size_factor_sanity</a> (size_t num, const SizeFactor_ *size_factors)</td></tr>
<tr class="separator:a8af1b1c1e7124933e4335f82fd41f027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16132309197e8d7a1d7d238a3685deda" id="r_a16132309197e8d7a1d7d238a3685deda"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:a16132309197e8d7a1d7d238a3685deda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a16132309197e8d7a1d7d238a3685deda">sanitize_size_factors</a> (size_t num, SizeFactor_ *size_factors, const <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> &amp;status, const <a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html">SanitizeSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:a16132309197e8d7a1d7d238a3685deda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe5b2dd6df09a56fbe0094fea4e4697" id="r_a8fe5b2dd6df09a56fbe0094fea4e4697"><td class="memTemplParams" colspan="2">template&lt;typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:a8fe5b2dd6df09a56fbe0094fea4e4697"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__norm.html#a8fe5b2dd6df09a56fbe0094fea4e4697">sanitize_size_factors</a> (size_t num, SizeFactor_ *size_factors, const <a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html">SanitizeSizeFactorsOptions</a> &amp;options)</td></tr>
<tr class="separator:a8fe5b2dd6df09a56fbe0094fea4e4697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Scaling normalization of single-cell data. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a47460312428a74877116e789da012aba" name="a47460312428a74877116e789da012aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47460312428a74877116e789da012aba">&#9670;&#160;</a></span>CenterBlockMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacescran__norm.html#a47460312428a74877116e789da012aba">scran_norm::CenterBlockMode</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Strategy for handling blocks when centering size factors, see <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a03777fea5bdfc1f386a60a88470e3422">CenterSizeFactorsOptions::block_mode</a></code> for details. </p>

</div>
</div>
<a id="a946ecb96a14f7df7cd0d5be4599766d2" name="a946ecb96a14f7df7cd0d5be4599766d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ecb96a14f7df7cd0d5be4599766d2">&#9670;&#160;</a></span>SanitizeAction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacescran__norm.html#a946ecb96a14f7df7cd0d5be4599766d2">scran_norm::SanitizeAction</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How invalid size factors should be handled:</p>
<ul>
<li><code>IGNORE</code>: ignore invalid size factors with no error or change.</li>
<li><code>ERROR</code>: throw an error.</li>
<li><code>SANITIZE</code>: fix each invalid size factor. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a01f3a3610590fb1286c4b7c8d0eb01c5" name="a01f3a3610590fb1286c4b7c8d0eb01c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f3a3610590fb1286c4b7c8d0eb01c5">&#9670;&#160;</a></span>center_size_factors_mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SizeFactor_ scran_norm::center_size_factors_mean </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the mean size factor but do not scale the size factors themselves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of length <code>num</code>, containing the size factor for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagnostics</td><td>Diagnostics for invalid size factors. This is only used if <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a09be0c48d2af10b0975c95b4f4ffa6cc">CenterSizeFactorsOptions::ignore_invalid</a> = true</code>, in which case it is filled with invalid diagnostics for values in <code>size_factors</code>. It can also be NULL, in which case it is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean size factor, to be used to divide each element of <code>size_factors</code>. </dd></dl>

</div>
</div>
<a id="a91783332304c92e0e02696d2e9358549" name="a91783332304c92e0e02696d2e9358549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91783332304c92e0e02696d2e9358549">&#9670;&#160;</a></span>center_size_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SizeFactor_ scran_norm::center_size_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When centering, we scale all size factors so that their mean is equal to 1. The aim is to ensure that the normalized expression values are on roughly the same scale as the original counts. This simplifies interpretation and ensures that any added pseudo-count prior to log-transformation has a predictable shrinkage effect. In general, size factors should be centered before calling <code><a class="el" href="namespacescran__norm.html#a141ebdc51024210f4c27902446fa4169">normalize_counts()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size_factors</td><td>Pointer to an array of length <code>num</code>, containing the size factor for each cell. On output, this contains centered size factors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagnostics</td><td>Diagnostics for invalid size factors. This is only used if <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a09be0c48d2af10b0975c95b4f4ffa6cc">CenterSizeFactorsOptions::ignore_invalid</a> = true</code>, in which case it is filled with invalid diagnostics for values in <code>size_factors</code>. It can also be NULL, in which case it is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mean size factor. </dd></dl>

</div>
</div>
<a id="af26c4087475faf7ba8a31d16a70669de" name="af26c4087475faf7ba8a31d16a70669de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c4087475faf7ba8a31d16a70669de">&#9670;&#160;</a></span>center_size_factors_blocked_mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SizeFactor_ &gt; scran_norm::center_size_factors_blocked_mean </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the mean size factor for each block, but do not scale the size factors themselves.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type for the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of length <code>num</code>, containing the size factor for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length <code>num</code>, containing the block assignment for each cell. Each assignment should be an integer in \([0, N)\) where \(N\) is the total number of blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagnostics</td><td>Diagnostics for invalid size factors. This is only used if <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a09be0c48d2af10b0975c95b4f4ffa6cc">CenterSizeFactorsOptions::ignore_invalid</a> = true</code>, in which case it is filled with invalid diagnostics for values in <code>size_factors</code>. It can also be NULL, in which case it is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length \(N\) containing the mean size factor for each block, to be used to scale the size factors in each block. </dd></dl>

</div>
</div>
<a id="ac59a8b6eca7e5c8d71cd21352b4ff393" name="ac59a8b6eca7e5c8d71cd21352b4ff393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59a8b6eca7e5c8d71cd21352b4ff393">&#9670;&#160;</a></span>center_size_factors_blocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SizeFactor_ &gt; scran_norm::center_size_factors_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> *&#160;</td>
          <td class="paramname"><em>diagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html">CenterSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center size factors within each block, using the strategy specified in <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a03777fea5bdfc1f386a60a88470e3422">CenterSizeFactorsOptions::block_mode</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type for the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of length <code>num</code>, containing the size factor for each cell. On output, this contains size factors that are centered according to <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a03777fea5bdfc1f386a60a88470e3422">CenterSizeFactorsOptions::block_mode</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length <code>num</code>, containing the block assignment for each cell. Each assignment should be an integer in \([0, N)\) where \(N\) is the total number of blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagnostics</td><td>Diagnostics for invalid size factors. This is only used if <code><a class="el" href="structscran__norm_1_1CenterSizeFactorsOptions.html#a09be0c48d2af10b0975c95b4f4ffa6cc">CenterSizeFactorsOptions::ignore_invalid</a> = true</code>, in which case it is filled with invalid diagnostics for values in <code>size_factors</code>. It can also be NULL, in which case it is ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length \(N\) containing the mean size factor for each block. </dd></dl>

</div>
</div>
<a id="aa12e0ead5f0365bd2c525b9597ed933d" name="aa12e0ead5f0365bd2c525b9597ed933d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12e0ead5f0365bd2c525b9597ed933d">&#9670;&#160;</a></span>choose_pseudo_count_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Float_ scran_norm::choose_pseudo_count_raw </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1ChoosePseudoCountOptions.html">ChoosePseudoCountOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose pseudo-count for log-transformation (see <code><a class="el" href="structscran__norm_1_1NormalizeCountsOptions.html#a3744450b615ed684b641ab552fa289db">NormalizeCountsOptions::pseudo_count</a></code>) that aims to control the transformation-induced bias. Specifically, the log-transform can introduce spurious differences in the expected log-normalized expression between cells with very different size factors. This bias can be mitigated by increasing the pseudo-count, which effectively shrinks all log-expression values towards the zero-expression baseline. The increased shrinkage is strongest at low counts where the log-transform bias is most pronounced, while the transformation of large counts is mostly unaffected.</p>
<p>In practice, the log-transformation bias is modest in datasets where there are stronger sources of variation. When observed, it manifests as a library size-dependent trend in the log-normalized expression values. This is difficult to regress out without also removing biology that is associated with, e.g., total RNA content; rather, a simpler solution is to increase the pseudo-count to suppress the bias.</p>
<p>No centering is performed by this function, so the size factors should be passed through <code><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors()</a></code> before calling functions here. Invalid size factors (e.g., zero, negative, non-finite) are automatically ignored, so prior sanitization should not be performed - this ensures that we do not include the replacement values in the various quantile calculations.</p>
<dl class="section see"><dt>See also</dt><dd>Lun ATL (2018). Overcoming systematic errors caused by log-transformation of normalized single-cell RNA sequencing data <em>biorXiv</em> doi:10.1101/404962</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of size factors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of size factors of length <code>num</code>. Values should be positive, and all non-positive values are ignored. On output, this array is arbitrarily permuted and should not be used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The suggested pseudo-count to control the log-transformation-induced bias below the specified threshold. </dd></dl>

</div>
</div>
<a id="a8948eac81e727615b19195686c81f666" name="a8948eac81e727615b19195686c81f666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8948eac81e727615b19195686c81f666">&#9670;&#160;</a></span>choose_pseudo_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Float_ scran_norm::choose_pseudo_count </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1ChoosePseudoCountOptions.html">ChoosePseudoCountOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function just wraps <code><a class="el" href="namespacescran__norm.html#aa12e0ead5f0365bd2c525b9597ed933d">choose_pseudo_count_raw()</a></code> with the automatic creation of a writeable buffer for the size factors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of size factors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of size factors of length <code>n</code>. Values should be positive, and all non-positive values are ignored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The suggested pseudo-count to control the log-transformation-induced bias below the specified threshold. </dd></dl>

</div>
</div>
<a id="a141ebdc51024210f4c27902446fa4169" name="a141ebdc51024210f4c27902446fa4169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141ebdc51024210f4c27902446fa4169">&#9670;&#160;</a></span>normalize_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputValue_  = double, typename InputValue_ , typename Index_ , class SizeFactors_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; OutputValue_, Index_ &gt; &gt; scran_norm::normalize_counts </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; InputValue_, Index_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFactors_&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1NormalizeCountsOptions.html">NormalizeCountsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a count matrix and a set of size factors, compute log-transformed normalized expression values. Each cell's counts are divided by the cell's size factor, to account for differences in capture efficiency and sequencing depth across cells. The normalized values are then log-transformed so that downstream analyses focus on the relative rather than absolute differences in expression; this process also provides some measure of variance stabilization. These operations are done in a delayed manner using the <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1DelayedUnaryIsometricOperation.html">tatami::DelayedUnaryIsometricOperation</a></code> class.</p>
<p>The simplest and most common method for defining size factors is to use the centered library sizes, see <code><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors()</a></code> for details. This removes scaling biases caused by sequencing depth, etc. between cells, while the centering preserves the scale of the counts in the (log-)normalized expression values. That said, users can define size factors from any method of their choice (e.g., median-based normalization, TMM) as long as they are positive for all cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputValue_</td><td>Floating-point type for the output matrix. </td></tr>
    <tr><td class="paramname">InputValue_</td><td>Data type for the input matrix. </td></tr>
    <tr><td class="paramname">InputIndex_</td><td>Integer type for the input matrix. </td></tr>
    <tr><td class="paramname">SizeFactors_</td><td>Container of floats for the size factors. This should have the <code>size()</code>, <code>begin()</code>, <code>end()</code> and <code>operator[]</code> methods.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counts</td><td>Pointer to a <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code> of gene-by-cell counts. </td></tr>
    <tr><td class="paramname">size_factors</td><td>Vector of length equal to the number of columns in <code>counts</code>, containing the size factor for each cell. All values should be positive. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of normalized expression values. These are log-transformed if <code><a class="el" href="structscran__norm_1_1NormalizeCountsOptions.html#a69a9473da69f8b86ba73b4b800a1268b">NormalizeCountsOptions::log</a> = true</code>. </dd></dl>

</div>
</div>
<a id="a8af1b1c1e7124933e4335f82fd41f027" name="a8af1b1c1e7124933e4335f82fd41f027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af1b1c1e7124933e4335f82fd41f027">&#9670;&#160;</a></span>check_size_factor_sanity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> scran_norm::check_size_factor_sanity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether there are any invalid size factors. Size factors are only technically valid if they are finite and positive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of size factors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_factors</td><td>Pointer to an array of size factors of length <code>num</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Validation results, indicating whether any zero or non-finite size factors exist. </dd></dl>

</div>
</div>
<a id="a16132309197e8d7a1d7d238a3685deda" name="a16132309197e8d7a1d7d238a3685deda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16132309197e8d7a1d7d238a3685deda">&#9670;&#160;</a></span>sanitize_size_factors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_norm::sanitize_size_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html">SanitizeSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace zero, missing or infinite values in the size factor array so that it can be used to compute well-defined normalized values. Such size factors can occasionally arise if, e.g., insufficient quality control was performed upstream. Check out the documentation in <code><a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html" title="Options for sanitize_size_factors().">SanitizeSizeFactorsOptions</a></code> to see what placeholder value is used for each type of invalid size factor.</p>
<p>In general, sanitization should occur after calls to <code><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors()</a></code>, <code><a class="el" href="namespacescran__norm.html#a8948eac81e727615b19195686c81f666">choose_pseudo_count()</a></code>, or any function that computes a statistic based on the distribution of size factors. This ensures that the results of those functions are not affected by the placeholder values used to replace the invalid size factors. As a rule of thumb, <code><a class="el" href="namespacescran__norm.html#a16132309197e8d7a1d7d238a3685deda">sanitize_size_factors()</a></code> should be called just before passing those size factors to <code><a class="el" href="namespacescran__norm.html#a141ebdc51024210f4c27902446fa4169">normalize_counts()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of size factors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size_factors</td><td>Pointer to an array of positive size factors of length <code>n</code>. On output, invalid size factors are replaced. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">status</td><td>A pre-computed object indicating whether invalid size factors are present in <code>size_factors</code>. This can be useful if this information is already provided by, e.g., <code><a class="el" href="namespacescran__norm.html#a8af1b1c1e7124933e4335f82fd41f027">check_size_factor_sanity()</a></code> or <code><a class="el" href="namespacescran__norm.html#a91783332304c92e0e02696d2e9358549">center_size_factors()</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe5b2dd6df09a56fbe0094fea4e4697" name="a8fe5b2dd6df09a56fbe0094fea4e4697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe5b2dd6df09a56fbe0094fea4e4697">&#9670;&#160;</a></span>sanitize_size_factors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__norm_1_1SizeFactorDiagnostics.html">SizeFactorDiagnostics</a> scran_norm::sanitize_size_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFactor_ *&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__norm_1_1SanitizeSizeFactorsOptions.html">SanitizeSizeFactorsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="namespacescran__norm.html#a16132309197e8d7a1d7d238a3685deda">sanitize_size_factors()</a></code> that calls <code><a class="el" href="namespacescran__norm.html#a8af1b1c1e7124933e4335f82fd41f027">check_size_factor_sanity()</a></code> internally.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeFactor_</td><td>Floating-point type for the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of size factors. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size_factors</td><td>Pointer to an array of positive size factors of length <code>n</code>. On output, invalid size factors are replaced. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object indicating whether each type of invalid size factors is present in <code>size_factors</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
